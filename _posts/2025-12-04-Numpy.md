---
title: NumPy Basics
date: 2025-12-04 13:03:00 +0800
categories: [Python, NumPy]
tags: [notes] # TAG names should always be lowercase
author: zora
description: "Python package -- NumPy basics learning notes"
toc: true
comments: false
---

Notes were taken from [W3Schools](https://www.w3schools.com/python/numpy/default.asp)

> NumPy is a Python library used for working with arrays.  
> It also has functions for working in domain of linear algebra, fourier transform, and matrices
>
> - NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.
> - The array object in NumPy is called `ndarray`, it provides a lot of supporting functions that make working with `ndarray` very easy.
{: .prompt-info}

## Creating Arrays

### Create a NumPy ndarray Object

Numpy is used to work with array. The array object is called `ndarray`. We can create a Numpy `ndarray` object by using the `array()` function  

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

print(arr)        # [1 2 3 4 5]
print(type(arr))  # <class 'numpy.ndarray'>
```

> To create an `ndarray`, we can pass a list, tuple or any array-like object into the `array()` method, and it will be converted into an `ndarray`:
{: .prompt-tip}

### Dimensions in Arrays

#### 0-D Arrays
>
> 0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.
{: .prompt-info}

``` python
import numpy as mp

arr = np.array(42)

print(arr)  # 42
```

#### 1-D Arrays

> An array that has 0-D arrays as its elements is called uni-dimensional or 1-D array. These are the most common and basic arrays
{: .prompt-info}

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

print(arr)  # [1 2 3 4 5]
```

#### 2-D Arrays

> An array that has 1-D arrays as its elements is called a 2-D array.
{: .prompt-info}

```python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr)
# [[1 2 3]
#  [4 5 6]]
```

#### 3-D Arrays

> An array that has 2-D arrays (matrices) as its elements is called 3-D array.
{: .prompt-info}

```python
import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])

print(arr)
# [[[1 2 3]
#   [4 5 6]]
#
#  [[1 2 3]
#   [4 5 6]]]
```

#### Check Number of Dimensions
>
> NumPy Arrays provides the `ndim` attribute that return an integer that tells us how many dimensions the array have
{: .prompt-info}

```python
import numpy as np
 
a = np.array(42)
b = np.array([1, 2, 3, 4, 5])
c = np.array([[1, 2, 3], [4, 5, 6]])
d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])

print(a.ndim)   # 0
print(b.ndim)   # 1
print(c.ndim)   # 2
print(d.ndim)   # 3
```

#### Higher Dimensional Arrays

> When the array is created, define the number of dimensions by using the `ndmin` argument.
{: .prompt-info}

``` python
import numpy as np

arr = np.array([1, 2, 3, 4], ndmin=5)

print(arr)    # [[[[[1 2 3 4]]]]]
print('number of dimensions :', arr.ndim)   # number of dimensions : 5
```

## NumPy Array Indexing

> Array indexing is the same as accessing an array element.
> Access an array element by referring to its index
{: .prompt-info}

``` python
import numpy as np

arr = np.array([1, 2, 3, 4])

print(arr[0])    # 1
```

### Access 2-D Arrays

``` python
import numpy as np

arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])

print('2nd element on 1st row: ', arr[0, 1])    # 2nd element on 1st dim:  2
```

### Access 3-D Arrays

``` python
import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

print(arr[0, 1, 2])   # 6
```

### Negative Indexing

> Use negative indexing to access an array from the end
{: .prompt-info}

```python
import numpy as np

arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])

print('Last element from 2nd dim: ', arr[1, -1])    # Last element from 2nd dim:  10
```

## NumPy Array Slicing

### Slicing Arrays

Slicing in python means taking elements from one given index to another given index.

- We pass slice instead of index like this: `[start:end]`.
- We can also define the step, like this: `[start:end:step]`.

> - If we don't pass start its considered 0  
> - If we don't pass end its considered length of array in that dimension  
> - If we don't pass step its considered 1
{: .prompt-tip}

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

# Slice elements from index 1 to index 5 from the following array:
print(arr[1:5])   # [2 3 4 5]

# Slice elements from index 4 to the end of the array:
print(arr[4:])    # [5 6 7]

# Slice elements from the beginning to index 4 (not included):
print(arr[:4])    # [1 2 3 4]

# Slice from the index 3 from the end to index 1 from the end:
print(arr[-3:-1])   # [5 6]

# Return every odd element from index 1 to index 5:
print(arr[1:5:2])   # [2 4]
```

#### Slicing 2-D Arrays

```python
import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

# From the second element, slice elements from index 1 to index 4 (not included):
print(arr[1, 1:4])    # [7 8 9]

# From both elements, return index 2:
print(arr[0:2, 2])    # [3 8]
```

## NumPy Data Types  

NumPy has some extra data types, and refer to data types with one character, like `i` for integers, `u` for unsigned integers etc.

- `i` - integer
- `b` - boolean
- `u` -unsigned integer
- `f` - float
- `c` - complex float
- `m` - timedelta
- `M` - datetime
- `O` - object
- `S` - string
- `U` - unicode string
- `V` - fixed chunk of memory for other type (void)

### Checking Data Type  

The NumPy array object has a property called `dtype` that returns the data type of the array

```python
import numpy as np

arr = np.array([1, 2, 3, 4])

print(arr.dtype)    # int64
```

### Creating Arrays with a Defined Data Type

We use the `array()` function to create arrays, this function can take an optional argument: `dtype` that allows us to define the expected data type of the array elements

```python
import numpy as np

arr = np.array([1, 2, 3, 4], dtype='S')

print(arr)          # [b'1' b'2' b'3' b'4']
print(arr.dtype)    # |S1
```

For `i`, `u`, `f`, `S` and `U` we can define size as well.

``` python
import numpy as np

# Create an array with data type 4 bytes integer
arr = np.array([1, 2, 3, 4], dtype='i4')

print(arr)          # [1 2 3 4]
print(arr.dtype)    # int32
```

### Converting Data Type on Existing Arrays  

The best way to change the data type of an existing array, is to make a copy of the array with the `astype()` method.  

- The `astype()` function creates a **copy of the array**, and allows you to specify the data type as a parameter.  

``` python
import numpy as np

arr = np.array([1.1, 2.1, 3.1])

newarr = arr.astype('i')

print(newarr)           # [1 2 3]
print(newarr.dtype)     # int32
```

## Copy vs View

The main difference between a copy and a view of an array is that the copy is a **new array**, and the view is just a **view of the original array**.  

### Copy

copy ***owns*** the data and any changes made to the copy **will not affect original array**, and any changes made to the original array will not affect the copy.  

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
x = arr.copy()
arr[0] = 42

print(arr)    # [42  2  3  4  5]
print(x)      # [1 2 3 4 5]
```

### View

The view ***does not own*** the data and any changes made to the view **will affect the original array**, and any changes made to the original array will affect the view.

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
x = arr.view()
arr[0] = 42

print(arr)    # [42  2  3  4  5]
print(x)      # [42  2  3  4  5]
```

### Check if Array Owns its Data  

- Every NumPy array has the attribute `base` that returns `None` if the array owns the data.
- Otherwise, the `base` attribute refers to the original object.

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

x = arr.copy()
y = arr.view()

print(x.base)   # None
print(y.base)   # [1 2 3 4 5]
```

## NumPy Array Shape  

The shape of an array is the **number of elements** in each dimension.

NumPy arrays have an attribute called `shape` that returns a tuple with each index having the number of corresponding elements.  

``` python
import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(arr.shape)    # (2, 4)
```  

> The example above returns (2, 4), which means that the array has 2 dimensions, where the first dimension has 2 elements and the second has 4.
{: .prompt-tip}

## NumPy Array Reshaping

- Reshaping means changing the shape of an array.
- The shape of an array is the number of elements in each dimension.
- By reshaping we can add or remove dimensions or change number of elements in each dimension.

### Reshape from 1-D to 2-D  

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(4, 3)

print(newarr)
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]
#  [10 11 12]]
```

### Reshape from 1-D to 3-D

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(2, 3, 2)

print(newarr)
# [[[ 1  2]
#   [ 3  4]
#   [ 5  6]]

#  [[ 7  8]
#   [ 9 10]
#   [11 12]]]
```

> We can reshape into any shape as long as the **elements required for reshaping are equal in both shapes**
{: .prompt-tip}

### Unknown Dimension

- Reshape allowed to have one "unknown" dimension, meaning that don't have to specify an exact number for one of the dimension in the reshape method.
- Pass `-1` as the value, and NumPy will calculate this number for you.

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])

# Convert 1D array with 8 elements to 3D array with 2x2 elements:
newarr = arr.reshape(2, 2, -1)

print(newarr)
# [[[1 2]
#   [3 4]]

#  [[5 6]
#   [7 8]]]
```

> We cannot pass `-1` to more than one dimension
{: .prompt-warning}

### Flattening the arrays

Flattening array means converting a multidimensional array into a 1D array.

- We can use `reshape(-1)` to do this.

``` python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

newarr = arr.reshape(-1)

print(newarr)   # [1 2 3 4 5 6]
```

> There are a lot of functions for changing the shapes of arrays in numpy `flatten`, `ravel` and also for rearranging the elements `rot90`, `flip`, `fliplr`, `flipud` etc. These fall under *Intermediate* to *Advanced* section of numpy.
{: .prompt-tip}

## NumPy Array Iterating

As we deal with multi-dimensional arrays in numpy, we can do this using basic `for` loop of python.

``` python
import numpy as np

# Iterate on the elements of the 1-D array:
arr = np.array([1, 2, 3])
for x in arr:
  print(x, end=" ")    # 1 2 3

# Iterate on the elements of the 2-D array:
arr = np.array([[1, 2, 3], [4, 5, 6]])
for x in arr:
  print(x)
# [1 2 3]
# [4 5 6]

# Iterate on each scalar element of the 2-D array:
arr = np.array([[1, 2, 3], [4, 5, 6]])
for x in arr:
  for y in x:
    print(y, end=" ")   # 1 2 3 4 5 6
```

### Iterating Arrays using nditer()

The function `nditer()` is a helping function that can be used from very basic to very advanced iterations.

> In basic `for` loops, iterating through each scalar of an array we need to use n `for` loops which can be difficult to write for arrays with very high dimensionality.
{: .prompt-tip}

```python
import numpy as np

arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

for x in np.nditer(arr):
  print(x, end=" ")

# 1 2 3 4 5 6 7 8
```

### Iterating Array with Different Data Types  

We can use `op_dtypes` argument and pass it the expected datatype to change the datatype of elements while iterating.  

``` python
import numpy as np

arr = np.array([1, 2, 3])

for x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):
  print(x, end=" ")

# b'1' b'2' b'3'
```

### Iterating With Different Step Size

``` python
import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])


# Iterate through every scalar element of the 2D array skipping 1 element:
for x in np.nditer(arr[:, ::2]):
  print(x, end=" ")

# 1 3 5 7
```

### Enumerated Iteration Using ndenumerate()  

> Enumeration means mentioning sequence number of somethings one by one.  

Sometimes we require corresponding index of the element while iterating, the `ndenumerate()` method can be used for those usecases.

``` python
import numpy as np

# Enumerate on following 1D arrays elements:
arr = np.array([1, 2, 3])
for idx, x in np.ndenumerate(arr):
  print(idx, x)

# (0,) 1
# (1,) 2
# (2,) 3

# Enumerate on following 2D array's elements:
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
for idx, x in np.ndenumerate(arr):
  print(idx, x)

# (0, 0) 1
# (0, 1) 2
# (0, 2) 3
# (0, 3) 4
# (1, 0) 5
# (1, 1) 6
# (1, 2) 7
# (1, 3) 8
```

## NumPy Joining Array  

> Joining means putting contents of two or more arrays in a single array.

### Joining Arrays

- In SQL we join tables based on a key, whereas in NumPy we join arrays by axes.
- Pass a sequence of arrays that we want to join to the `concatenate()` function, along with the axis. If axis is not explicitly passed, it is taken as 0.

``` python
import numpy as np

# Join two arrays:
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.concatenate((arr1, arr2))
print(arr)    # [1 2 3 4 5 6]

# Join two 2-D arrays along rows (axis = 1):
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])
arr = np.concatenate((arr1, arr2), axis=1)
print(arr)
# [[1 2 5 6]
#  [3 4 7 8]]
```

### Joining Arrays Using Stack Function
>
> Stacking is same as concatenation, the only difference is that stacking is done along a new axis.

- We can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.
- Pass a sequence of arrays that we want to join to the `stack()` method along with the axis. If axis is not explicitly passed it is taken as 0.  

``` python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.stack((arr1, arr2), axis=1)

print(arr)
# [[1 4]
#  [2 5]
#  [3 6]]
```

#### Stacking Along Rows  

NumPy provides a helper function: `hstack()` to stack along rows.

``` python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.hstack((arr1, arr2))

print(arr)    # [1 2 3 4 5 6]
```

#### Stacking Along Columns  

NumPy provides a helper function: `vstack()` to stack along columns.

```python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.vstack((arr1, arr2))

print(arr)
# [[1 2 3]
#  [4 5 6]]
```

#### Stacking Along Height (depth)

NumPy provides a helper function: `dstack()` to stack along height, which is the same as depth.

``` python
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.dstack((arr1, arr2))

print(arr)
# [[[1 4]
#   [2 5]
#   [3 6]]]
```

## NumPy Splitting Array

### Splitting NumPy Array
>
> Splitting is reverse operation of Joining.  
> Joining merges multiple arrays into one and Splitting breaks one array into multiple.

We use `array_split()` for splitting arrays, we pass it the array we want to split and the number of splits.

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])

newarr = np.array_split(arr, 3)

print(newarr)   # [array([1, 2]), array([3, 4]), array([5, 6])]
```

> The return value is a list containing three arrays
{: .prompt-info}

If the array has less elements than required, it will adjust from the end accordingly.  

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])

newarr = np.array_split(arr, 4)

print(newarr)   # [array([1, 2]), array([3, 4]), array([5]), array([6])]
```

> We also have the method `split()` available but it will not adjust the elements when elements are less in source array for splitting like in example above, `array_split()` worked properly but `split()` would fail.
{: .prompt-info}

### Split Into Arrays  

The return value of the `array_split()` method is a list containing each of the split as an array.
> If you split an array into 3 arrays, you can access them from the result just like any array element

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])

newarr = np.array_split(arr, 3)

print(newarr[0])    # [1 2]
print(newarr[1])    # [3 4]
print(newarr[2])    # [5 6]
```

### Splitting 2-D Arrays  

Use the `array_split()` method, pass in the array you want to split and the number of splits you want to do.

``` python
import numpy as np

# Split the 2-D array into three 2-D arrays.
arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])
newarr = np.array_split(arr, 3)
print(newarr)
# [array([[1, 2],
#        [3, 4]]), array([[5, 6],
#        [7, 8]]), array([[ 9, 10],
#        [11, 12]])]


# Split the 2-D array into three 2-D arrays along columns.
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.array_split(arr, 3, axis=1)
print(newarr)

# [array([[ 1],
#        [ 4],
#        [ 7],
#        [10],
#        [13],
#        [16]]), array([[ 2],
#        [ 5],
#        [ 8],
#        [11],
#        [14],
#        [17]]), array([[ 3],
#        [ 6],
#        [ 9],
#        [12],
#        [15],
#        [18]])]
```

> - An alternate solution is using `hsplit()` opposite of `hstack()`
> - Similar alternates to `vstack()` and `dstack()` are available as `vsplit()` and `dsplit()`.
{: .prompt-tip}

## Numpy Searching Arrays

### Searching Arrays

You can search an array for a certain value, and return the indexes that get a match.

- To search an array, use the `where()` method.  

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 4, 4])

# Find the indexes where the value is 4:
x = np.where(arr == 4)

print(x)    # (array([3, 5, 6]),)
```

>The example above will return a tuple: `(array([3, 5, 6],)`, which means that the value 4 is present at index 3, 5, and 6.
{: .prompt-info}

Find the indexed where the values are even:

``` python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])

x = np.where(arr%2 == 0)

print(x)    # (array([1, 3, 5, 7]),)
```

### Search Sorted

There is a method called `searchsorted()` which performs a binary search in the array, and returns the index where the specified value would be inserted to maintain the search order.

> The `searchsorted()` method is assumed to be used on sorted arrays.
{: .prompt-tip}

``` python
import numpy as np

arr = np.array([6, 7, 8, 9])

# Find the indexes where the value 7 should be inserted:
x = np.searchsorted(arr, 7)

print(x)    # 1
```

> Example explained: The number 7 should be inserted on index 1 to remain the sort order.  
> The method starts the search from the left and returns the first index where the number 7 is no longer larger than the next value.

#### Search From the Right Side

By default the left most index is returned, but we can give `side='right'` to return the right most index instead.

``` python
import numpy as np

arr = np.array([6, 7, 8, 9])

x = np.searchsorted(arr, 7, side='right')

print(x)    # 2
```

> Example explained: The number 7 should be inserted on index 2 to remain the sort order.  
> The method starts the search from the right and returns the first index where the number 7 is no longer less than the next value.

#### Multiple Values

To search for more than one value, use an array with the specified values.

``` python
import numpy as np

arr = np.array([1, 3, 5, 7])

x = np.searchsorted(arr, [2, 4, 6])

print(x)    # [1 2 3]
```

> The return value is an array: [1 2 3] containing the three indexes where 2, 4, 6 would be inserted in the original array to maintain the order.

## NumPy Sorting Arrays

### Sorting Arrays

The NumPy ndarray object has a function called `sort()`, that will sort a specified array.

``` python
import numpy as np

arr = np.array([3, 2, 0, 1])

print(np.sort(arr))   # [0 1 2 3]
```

> This method returns a copy of the array, leaving the original array unchanged.
{: .prompt-tip}
> Can also sort arrays of strings, or any other data type
{: .prompt-info}

### Sorting 2-D Array

If use the `sort()` method on a 2-D array, both arrays will be sorted

``` python
import numpy as np

arr = np.array([[3, 2, 4], [5, 0, 1]])

print(np.sort(arr))
# [[2 3 4]
#  [0 1 5]]
```

## NumPy Filter Array

### Filtering Arrays

In NumPy, you filter an array using a boolean index list.

> A boolean index list is a list of booleans corresponding to indexes in the array.
{: .prompt-info}

If the value at an index is `True` that element is contained in the filtered array, if the value at that index is `False` that element is excluded from the filtered array.

``` python
import numpy as np

arr = np.array([41, 42, 43, 44])

x = [True, False, True, False]

newarr = arr[x]

print(newarr)   #[41 43]
```

### Creating the Filter Array

``` python
# Create a filter array that will return only values higher than 42:
import numpy as np

arr = np.array([41, 42, 43, 44])

# Create an empty list
filter_arr = []

# go through each element in arr
for element in arr:
  # if the element is higher than 42, set the value to True, otherwise False:
  if element > 42:
    filter_arr.append(True)
  else:
    filter_arr.append(False)

newarr = arr[filter_arr]

print(filter_arr)   # [False, False, True, True]
print(newarr)       # [43 44]
```

### Creating Filter Directly From Array

We can directly substitute the array instead of the iterable variable in our condition and it will work just as we expect it to.

``` python
import numpy as np

arr = np.array([41, 42, 43, 44])

filter_arr = arr > 42

newarr = arr[filter_arr]

print(filter_arr)   # [False False  True  True]
print(newarr)       # [43 44]
```
